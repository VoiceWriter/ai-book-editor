#!/usr/bin/env python3
"""
Perform scheduled full-book editorial review.

This script:
1. Reads all chapters
2. Analyzes for structural issues, redundancy, gaps
3. Creates GitHub issues for discovered problems
4. Can generate AI questions for needed context
"""

import json
import os
import sys

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from scripts.utils.github_client import (
    get_github_client,  # noqa: E402
    get_repo,
    list_files_in_directory,
    read_file_content,
)
from scripts.utils.knowledge_base import load_editorial_context  # noqa: E402
from scripts.utils.llm_client import build_editorial_prompt, call_editorial  # noqa: E402


def load_all_chapters(repo) -> dict:
    """Load all chapter content."""
    chapters = {}
    chapter_files = list_files_in_directory(repo, "chapters")

    for filename in chapter_files:
        if filename.endswith(".md"):
            content = read_file_content(repo, f"chapters/{filename}")
            if content:
                chapters[filename] = content

    return chapters


def parse_issues_from_response(response: str) -> list:
    """Parse structured issues from Claude's response."""
    issues = []

    # Look for JSON block
    if "```json" in response:
        try:
            json_match = response.split("```json")[1].split("```")[0]
            issues = json.loads(json_match)
        except (IndexError, json.JSONDecodeError):
            pass

    return issues


def main():
    gh = get_github_client()
    repo = get_repo(gh)

    # Load all chapters
    print("Loading chapters...")
    chapters = load_all_chapters(repo)

    if not chapters:
        print("No chapters found.")
        sys.exit(0)

    # Load editorial context
    context = load_editorial_context(repo)

    # Build chapter summary for prompt
    chapters_text = ""
    for filename, content in sorted(chapters.items()):
        word_count = len(content.split())
        chapters_text += f"\n### {filename} ({word_count} words)\n{content[:2000]}...\n"

    task = f"""Perform a comprehensive editorial review of this book manuscript.

**Chapters ({len(chapters)} total, {sum(len(c.split()) for c in chapters.values())} words):**
{chapters_text}

Analyze for:

1. **Structural Issues**
   - Flow and organization problems
   - Chapters in wrong order
   - Missing transitions between sections

2. **Redundancy**
   - Content repeated across chapters
   - Ideas stated multiple times
   - Overlapping sections

3. **Content Gaps**
   - Missing explanations
   - Promised topics not covered
   - Logical jumps

4. **Consistency Issues**
   - Terminology inconsistencies
   - Voice/tone shifts
   - Contradictions

5. **Pacing Problems**
   - Sections too long or short
   - Rushed or dragging areas

For each issue found, provide:
- Type (structural/redundancy/gap/consistency/pacing)
- Location (which chapter(s))
- Description of the problem
- Suggested resolution

Also identify 1-3 questions you need answered to provide better feedback.

Return your findings as JSON:
```json
[
  {{"type": "structural", "location": "chapter-01.md", "title": "Brief title", "description": "...", "suggestion": "..."}},
  {{"type": "question", "question": "...", "why": "..."}}
]
```"""

    prompt = build_editorial_prompt(
        persona=context["persona"],
        guidelines=context["guidelines"],
        glossary=context["glossary"],
        knowledge_base=context["knowledge_formatted"],
        chapter_list=list(chapters.keys()),
        task=task,
        content="",
    )

    print("Calling LLM for full book analysis...")
    llm_response = call_editorial(prompt)
    response = llm_response.content

    # Parse issues
    issues = parse_issues_from_response(response)

    if not issues:
        print("No issues parsed from response. Creating summary issue instead.")
        repo.create_issue(
            title="Weekly Editorial Review Summary",
            body=f"## Full Book Analysis\n\n{response}\n\n---\n*Generated by AI Book Editor*",
            labels=["ai-suggestion"],
        )
        sys.exit(0)

    # Create issues for each finding
    created_count = 0
    for item in issues:
        if item.get("type") == "question":
            # Create AI question issue
            repo.create_issue(
                title=f"[AI Question] {item['question'][:60]}",
                body=f"""## Question from AI Editor

{item['question']}

---

**Why I'm asking:** {item.get('why', 'I need this context to provide better editorial feedback.')}

**How to respond:** Just reply to this issue. I'll extract the answer and remember it for future editing sessions.

---
*This question was automatically generated during weekly book review.*
""",
                labels=["ai-question", "awaiting-author"],
            )
            created_count += 1
        else:
            # Create editorial issue
            repo.create_issue(
                title=f"[{item['type'].title()}] {item.get('title', item['description'][:50])}",
                body=f"""## Editorial Issue

**Type:** {item['type']}
**Location:** {item.get('location', 'Multiple chapters')}

### Problem
{item['description']}

### Suggested Resolution
{item.get('suggestion', 'No specific suggestion provided.')}

---

**Next steps:**
- Comment if you want to discuss
- Add `approved` label if you want me to create a PR
- Close if this is intentional

---
*This issue was automatically generated during weekly book review.*
""",
                labels=["ai-suggestion", item["type"]],
            )
            created_count += 1

    print(f"Created {created_count} issues from book review.")


if __name__ == "__main__":
    main()
